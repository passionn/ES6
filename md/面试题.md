#### 1、排序
冒泡排序：
思想：每一次比较相邻两个数据的大小，小的排在前面，如果前面的数据比后面的大就叫唤两个数的位置，要实现上述规则需要用到两层循环，；
```
function sort(arr){
	for(var i=0;i<arr.lenght-1;i++){
		for(var j=i+1;j<arr.length;j++){
			if(arr[i]>arr[j]){
				var temp=arr[i];
				arr[i]=arr[j];
				arr[j]=temp;
			}
		}
	}
	return arr;
}
```
快速排序；
思想：先找到一个基准点（一般指数组的中部），然后数组被基准点分为两部分，依次与该基准点数据比较，如果比他小，放左边；反之放右边。
		左右分别用一个空数组去存储比较后的数据，最后递归执行上述草最，直到数组的长度＜＝１；
```
function quickSort(arr){
	if(arr.lenght<=1){
		return arr;
	}

	var midIndex=Math.floor(arr.length/2);
	var midIndexVal=arr.splice(midIndex,1)[0];
	var left=[];
	var right=[];

	for(var i=0;i<arr.length;i++){
		if(arr[i]<midIndexVal){
			left.push(arr[i]);
		}else{
			right.push(arr[i]);
		}

	}
	return quickSort(left).concat(midIndexVal,quickSort(right));
}
```
#### 2、數組去重
循環去重；
對象屬性去重；
```
function norepeat(arr){
   var obj={};
   var newarr=[];
   for(var i=0;i<arr.length;i++){
		if(!obj[arr[i]]){
			obj[arr[i]]=true;
            newarr.push(arr[i]);		
		}	
	}
   return newarr;
}

```
### 3、深複製前複製

深度复制
```
function deepClone(obj){
    var str,newobj=obj.constructor===Arrary?[]:{};
    if(typeof obj!==='object'){
        return;
    }else{
        for(var i in obj){
            newobj[i]=typeof obj[i] === 'object'? cloneObj(obj[i]):obj[i];
        }
    }

    return newobj;
}

```

浅复制
```
 function clone(obj){
     var newobj=obj.constructor===Arrary?[]:{};
         for(var i in obj){
             newobj[i]=obj[i];
         }
 }

```
### 4、原型链、继承
```
function extend(child,parent){
        var F=function(){};
        F.prototype=parent.prototype;
        child.prototype=new F();
        child.prototype.constructor=child;
}
```

### 5、数组方法
slice() 从已有的数组中返回选定的元素；
splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目；
push();
pop();
shift();
unshift();
```
arrayObject.slice(start,end);
/**
* @parames index 必须，整数，规定添加/删除项目的位置。使用负数可以从数组结尾处规定位置。
* @parames howmany 必需，要删除项目的数量，如果设置为0，则不会删除项目。
* @parames item1, ..., itemX 可选，想数组添加 新项目。
*/
arrayObject.splice(index,howmany,item1,.....,itemX);

```
